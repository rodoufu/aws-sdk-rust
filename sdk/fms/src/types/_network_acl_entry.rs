// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a rule in a network ACL.</p>
/// <p>Each network ACL has a set of numbered ingress rules and a separate set of numbered egress rules. When determining whether a packet should be allowed in or out of a subnet associated with the network ACL, Amazon Web Services processes the entries in the network ACL according to the rule numbers, in ascending order.</p>
/// <p>When you manage an individual network ACL, you explicitly specify the rule numbers. When you specify the network ACL rules in a Firewall Manager policy, you provide the rules to run first, in the order that you want them to run, and the rules to run last, in the order that you want them to run. Firewall Manager assigns the rule numbers for you when you save the network ACL policy specification.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NetworkAclEntry {
    /// <p>ICMP protocol: The ICMP type and code.</p>
    pub icmp_type_code: ::std::option::Option<crate::types::NetworkAclIcmpTypeCode>,
    /// <p>The protocol number. A value of "-1" means all protocols.</p>
    pub protocol: ::std::string::String,
    /// <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
    pub port_range: ::std::option::Option<crate::types::NetworkAclPortRange>,
    /// <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
    pub cidr_block: ::std::option::Option<::std::string::String>,
    /// <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
    pub ipv6_cidr_block: ::std::option::Option<::std::string::String>,
    /// <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
    pub rule_action: crate::types::NetworkAclRuleAction,
    /// <p>Indicates whether the rule is an egress, or outbound, rule (applied to traffic leaving the subnet). If it's not an egress rule, then it's an ingress, or inbound, rule.</p>
    pub egress: bool,
}
impl NetworkAclEntry {
    /// <p>ICMP protocol: The ICMP type and code.</p>
    pub fn icmp_type_code(&self) -> ::std::option::Option<&crate::types::NetworkAclIcmpTypeCode> {
        self.icmp_type_code.as_ref()
    }
    /// <p>The protocol number. A value of "-1" means all protocols.</p>
    pub fn protocol(&self) -> &str {
        use std::ops::Deref;
        self.protocol.deref()
    }
    /// <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
    pub fn port_range(&self) -> ::std::option::Option<&crate::types::NetworkAclPortRange> {
        self.port_range.as_ref()
    }
    /// <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
    pub fn cidr_block(&self) -> ::std::option::Option<&str> {
        self.cidr_block.as_deref()
    }
    /// <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
    pub fn ipv6_cidr_block(&self) -> ::std::option::Option<&str> {
        self.ipv6_cidr_block.as_deref()
    }
    /// <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
    pub fn rule_action(&self) -> &crate::types::NetworkAclRuleAction {
        &self.rule_action
    }
    /// <p>Indicates whether the rule is an egress, or outbound, rule (applied to traffic leaving the subnet). If it's not an egress rule, then it's an ingress, or inbound, rule.</p>
    pub fn egress(&self) -> bool {
        self.egress
    }
}
impl NetworkAclEntry {
    /// Creates a new builder-style object to manufacture [`NetworkAclEntry`](crate::types::NetworkAclEntry).
    pub fn builder() -> crate::types::builders::NetworkAclEntryBuilder {
        crate::types::builders::NetworkAclEntryBuilder::default()
    }
}

/// A builder for [`NetworkAclEntry`](crate::types::NetworkAclEntry).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct NetworkAclEntryBuilder {
    pub(crate) icmp_type_code: ::std::option::Option<crate::types::NetworkAclIcmpTypeCode>,
    pub(crate) protocol: ::std::option::Option<::std::string::String>,
    pub(crate) port_range: ::std::option::Option<crate::types::NetworkAclPortRange>,
    pub(crate) cidr_block: ::std::option::Option<::std::string::String>,
    pub(crate) ipv6_cidr_block: ::std::option::Option<::std::string::String>,
    pub(crate) rule_action: ::std::option::Option<crate::types::NetworkAclRuleAction>,
    pub(crate) egress: ::std::option::Option<bool>,
}
impl NetworkAclEntryBuilder {
    /// <p>ICMP protocol: The ICMP type and code.</p>
    pub fn icmp_type_code(mut self, input: crate::types::NetworkAclIcmpTypeCode) -> Self {
        self.icmp_type_code = ::std::option::Option::Some(input);
        self
    }
    /// <p>ICMP protocol: The ICMP type and code.</p>
    pub fn set_icmp_type_code(mut self, input: ::std::option::Option<crate::types::NetworkAclIcmpTypeCode>) -> Self {
        self.icmp_type_code = input;
        self
    }
    /// <p>ICMP protocol: The ICMP type and code.</p>
    pub fn get_icmp_type_code(&self) -> &::std::option::Option<crate::types::NetworkAclIcmpTypeCode> {
        &self.icmp_type_code
    }
    /// <p>The protocol number. A value of "-1" means all protocols.</p>
    /// This field is required.
    pub fn protocol(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.protocol = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The protocol number. A value of "-1" means all protocols.</p>
    pub fn set_protocol(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.protocol = input;
        self
    }
    /// <p>The protocol number. A value of "-1" means all protocols.</p>
    pub fn get_protocol(&self) -> &::std::option::Option<::std::string::String> {
        &self.protocol
    }
    /// <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
    pub fn port_range(mut self, input: crate::types::NetworkAclPortRange) -> Self {
        self.port_range = ::std::option::Option::Some(input);
        self
    }
    /// <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
    pub fn set_port_range(mut self, input: ::std::option::Option<crate::types::NetworkAclPortRange>) -> Self {
        self.port_range = input;
        self
    }
    /// <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
    pub fn get_port_range(&self) -> &::std::option::Option<crate::types::NetworkAclPortRange> {
        &self.port_range
    }
    /// <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
    pub fn cidr_block(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cidr_block = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
    pub fn set_cidr_block(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cidr_block = input;
        self
    }
    /// <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
    pub fn get_cidr_block(&self) -> &::std::option::Option<::std::string::String> {
        &self.cidr_block
    }
    /// <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
    pub fn ipv6_cidr_block(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ipv6_cidr_block = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
    pub fn set_ipv6_cidr_block(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ipv6_cidr_block = input;
        self
    }
    /// <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
    pub fn get_ipv6_cidr_block(&self) -> &::std::option::Option<::std::string::String> {
        &self.ipv6_cidr_block
    }
    /// <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
    /// This field is required.
    pub fn rule_action(mut self, input: crate::types::NetworkAclRuleAction) -> Self {
        self.rule_action = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
    pub fn set_rule_action(mut self, input: ::std::option::Option<crate::types::NetworkAclRuleAction>) -> Self {
        self.rule_action = input;
        self
    }
    /// <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
    pub fn get_rule_action(&self) -> &::std::option::Option<crate::types::NetworkAclRuleAction> {
        &self.rule_action
    }
    /// <p>Indicates whether the rule is an egress, or outbound, rule (applied to traffic leaving the subnet). If it's not an egress rule, then it's an ingress, or inbound, rule.</p>
    /// This field is required.
    pub fn egress(mut self, input: bool) -> Self {
        self.egress = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the rule is an egress, or outbound, rule (applied to traffic leaving the subnet). If it's not an egress rule, then it's an ingress, or inbound, rule.</p>
    pub fn set_egress(mut self, input: ::std::option::Option<bool>) -> Self {
        self.egress = input;
        self
    }
    /// <p>Indicates whether the rule is an egress, or outbound, rule (applied to traffic leaving the subnet). If it's not an egress rule, then it's an ingress, or inbound, rule.</p>
    pub fn get_egress(&self) -> &::std::option::Option<bool> {
        &self.egress
    }
    /// Consumes the builder and constructs a [`NetworkAclEntry`](crate::types::NetworkAclEntry).
    /// This method will fail if any of the following fields are not set:
    /// - [`protocol`](crate::types::builders::NetworkAclEntryBuilder::protocol)
    /// - [`rule_action`](crate::types::builders::NetworkAclEntryBuilder::rule_action)
    /// - [`egress`](crate::types::builders::NetworkAclEntryBuilder::egress)
    pub fn build(self) -> ::std::result::Result<crate::types::NetworkAclEntry, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::NetworkAclEntry {
            icmp_type_code: self.icmp_type_code,
            protocol: self.protocol.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "protocol",
                    "protocol was not specified but it is required when building NetworkAclEntry",
                )
            })?,
            port_range: self.port_range,
            cidr_block: self.cidr_block,
            ipv6_cidr_block: self.ipv6_cidr_block,
            rule_action: self.rule_action.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "rule_action",
                    "rule_action was not specified but it is required when building NetworkAclEntry",
                )
            })?,
            egress: self.egress.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "egress",
                    "egress was not specified but it is required when building NetworkAclEntry",
                )
            })?,
        })
    }
}
