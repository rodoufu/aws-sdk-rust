// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateContainerGroupDefinitionInput {
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The method for deploying the container group across fleet instances. A replica container group might have multiple copies on each fleet instance. A daemon container group has one copy per fleet instance. Default value is <code>REPLICA</code>.</p>
    pub scheduling_strategy: ::std::option::Option<crate::types::ContainerSchedulingStrategy>,
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for individual containers, set this parameter based on the following guidelines. The value must be (1) greater than the sum of the soft memory limits for all containers in the group, and (2) greater than any individual container's hard memory limit.</p>
    pub total_memory_limit: ::std::option::Option<i32>,
    /// <p>The maximum amount of CPU units to allocate to the container group. Set this parameter to an integer value in CPU units (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify CPU limits for individual containers, set this parameter based on the following guidelines. The value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    pub total_cpu_limit: ::std::option::Option<i32>,
    /// <p>Definitions for all containers in this group. Each container definition identifies the container image and specifies configuration settings for the container. See the <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-design-fleet.html"> Container fleet design guide</a> for container guidelines.</p>
    pub container_definitions: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDefinitionInput>>,
    /// <p>The platform that is used by containers in the container group definition. All containers in a group must run on the same operating system.</p>
    pub operating_system: ::std::option::Option<crate::types::ContainerOperatingSystem>,
    /// <p>A list of labels to assign to the container group definition resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreateContainerGroupDefinitionInput {
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The method for deploying the container group across fleet instances. A replica container group might have multiple copies on each fleet instance. A daemon container group has one copy per fleet instance. Default value is <code>REPLICA</code>.</p>
    pub fn scheduling_strategy(&self) -> ::std::option::Option<&crate::types::ContainerSchedulingStrategy> {
        self.scheduling_strategy.as_ref()
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for individual containers, set this parameter based on the following guidelines. The value must be (1) greater than the sum of the soft memory limits for all containers in the group, and (2) greater than any individual container's hard memory limit.</p>
    pub fn total_memory_limit(&self) -> ::std::option::Option<i32> {
        self.total_memory_limit
    }
    /// <p>The maximum amount of CPU units to allocate to the container group. Set this parameter to an integer value in CPU units (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify CPU limits for individual containers, set this parameter based on the following guidelines. The value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    pub fn total_cpu_limit(&self) -> ::std::option::Option<i32> {
        self.total_cpu_limit
    }
    /// <p>Definitions for all containers in this group. Each container definition identifies the container image and specifies configuration settings for the container. See the <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-design-fleet.html"> Container fleet design guide</a> for container guidelines.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.container_definitions.is_none()`.
    pub fn container_definitions(&self) -> &[crate::types::ContainerDefinitionInput] {
        self.container_definitions.as_deref().unwrap_or_default()
    }
    /// <p>The platform that is used by containers in the container group definition. All containers in a group must run on the same operating system.</p>
    pub fn operating_system(&self) -> ::std::option::Option<&crate::types::ContainerOperatingSystem> {
        self.operating_system.as_ref()
    }
    /// <p>A list of labels to assign to the container group definition resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
}
impl CreateContainerGroupDefinitionInput {
    /// Creates a new builder-style object to manufacture [`CreateContainerGroupDefinitionInput`](crate::operation::create_container_group_definition::CreateContainerGroupDefinitionInput).
    pub fn builder() -> crate::operation::create_container_group_definition::builders::CreateContainerGroupDefinitionInputBuilder {
        crate::operation::create_container_group_definition::builders::CreateContainerGroupDefinitionInputBuilder::default()
    }
}

/// A builder for [`CreateContainerGroupDefinitionInput`](crate::operation::create_container_group_definition::CreateContainerGroupDefinitionInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CreateContainerGroupDefinitionInputBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) scheduling_strategy: ::std::option::Option<crate::types::ContainerSchedulingStrategy>,
    pub(crate) total_memory_limit: ::std::option::Option<i32>,
    pub(crate) total_cpu_limit: ::std::option::Option<i32>,
    pub(crate) container_definitions: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDefinitionInput>>,
    pub(crate) operating_system: ::std::option::Option<crate::types::ContainerOperatingSystem>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl CreateContainerGroupDefinitionInputBuilder {
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The method for deploying the container group across fleet instances. A replica container group might have multiple copies on each fleet instance. A daemon container group has one copy per fleet instance. Default value is <code>REPLICA</code>.</p>
    pub fn scheduling_strategy(mut self, input: crate::types::ContainerSchedulingStrategy) -> Self {
        self.scheduling_strategy = ::std::option::Option::Some(input);
        self
    }
    /// <p>The method for deploying the container group across fleet instances. A replica container group might have multiple copies on each fleet instance. A daemon container group has one copy per fleet instance. Default value is <code>REPLICA</code>.</p>
    pub fn set_scheduling_strategy(mut self, input: ::std::option::Option<crate::types::ContainerSchedulingStrategy>) -> Self {
        self.scheduling_strategy = input;
        self
    }
    /// <p>The method for deploying the container group across fleet instances. A replica container group might have multiple copies on each fleet instance. A daemon container group has one copy per fleet instance. Default value is <code>REPLICA</code>.</p>
    pub fn get_scheduling_strategy(&self) -> &::std::option::Option<crate::types::ContainerSchedulingStrategy> {
        &self.scheduling_strategy
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for individual containers, set this parameter based on the following guidelines. The value must be (1) greater than the sum of the soft memory limits for all containers in the group, and (2) greater than any individual container's hard memory limit.</p>
    /// This field is required.
    pub fn total_memory_limit(mut self, input: i32) -> Self {
        self.total_memory_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for individual containers, set this parameter based on the following guidelines. The value must be (1) greater than the sum of the soft memory limits for all containers in the group, and (2) greater than any individual container's hard memory limit.</p>
    pub fn set_total_memory_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_memory_limit = input;
        self
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for individual containers, set this parameter based on the following guidelines. The value must be (1) greater than the sum of the soft memory limits for all containers in the group, and (2) greater than any individual container's hard memory limit.</p>
    pub fn get_total_memory_limit(&self) -> &::std::option::Option<i32> {
        &self.total_memory_limit
    }
    /// <p>The maximum amount of CPU units to allocate to the container group. Set this parameter to an integer value in CPU units (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify CPU limits for individual containers, set this parameter based on the following guidelines. The value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    /// This field is required.
    pub fn total_cpu_limit(mut self, input: i32) -> Self {
        self.total_cpu_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum amount of CPU units to allocate to the container group. Set this parameter to an integer value in CPU units (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify CPU limits for individual containers, set this parameter based on the following guidelines. The value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    pub fn set_total_cpu_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_cpu_limit = input;
        self
    }
    /// <p>The maximum amount of CPU units to allocate to the container group. Set this parameter to an integer value in CPU units (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify CPU limits for individual containers, set this parameter based on the following guidelines. The value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    pub fn get_total_cpu_limit(&self) -> &::std::option::Option<i32> {
        &self.total_cpu_limit
    }
    /// Appends an item to `container_definitions`.
    ///
    /// To override the contents of this collection use [`set_container_definitions`](Self::set_container_definitions).
    ///
    /// <p>Definitions for all containers in this group. Each container definition identifies the container image and specifies configuration settings for the container. See the <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-design-fleet.html"> Container fleet design guide</a> for container guidelines.</p>
    pub fn container_definitions(mut self, input: crate::types::ContainerDefinitionInput) -> Self {
        let mut v = self.container_definitions.unwrap_or_default();
        v.push(input);
        self.container_definitions = ::std::option::Option::Some(v);
        self
    }
    /// <p>Definitions for all containers in this group. Each container definition identifies the container image and specifies configuration settings for the container. See the <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-design-fleet.html"> Container fleet design guide</a> for container guidelines.</p>
    pub fn set_container_definitions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDefinitionInput>>) -> Self {
        self.container_definitions = input;
        self
    }
    /// <p>Definitions for all containers in this group. Each container definition identifies the container image and specifies configuration settings for the container. See the <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-design-fleet.html"> Container fleet design guide</a> for container guidelines.</p>
    pub fn get_container_definitions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerDefinitionInput>> {
        &self.container_definitions
    }
    /// <p>The platform that is used by containers in the container group definition. All containers in a group must run on the same operating system.</p>
    /// This field is required.
    pub fn operating_system(mut self, input: crate::types::ContainerOperatingSystem) -> Self {
        self.operating_system = ::std::option::Option::Some(input);
        self
    }
    /// <p>The platform that is used by containers in the container group definition. All containers in a group must run on the same operating system.</p>
    pub fn set_operating_system(mut self, input: ::std::option::Option<crate::types::ContainerOperatingSystem>) -> Self {
        self.operating_system = input;
        self
    }
    /// <p>The platform that is used by containers in the container group definition. All containers in a group must run on the same operating system.</p>
    pub fn get_operating_system(&self) -> &::std::option::Option<crate::types::ContainerOperatingSystem> {
        &self.operating_system
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of labels to assign to the container group definition resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of labels to assign to the container group definition resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>A list of labels to assign to the container group definition resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreateContainerGroupDefinitionInput`](crate::operation::create_container_group_definition::CreateContainerGroupDefinitionInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_container_group_definition::CreateContainerGroupDefinitionInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::create_container_group_definition::CreateContainerGroupDefinitionInput {
            name: self.name,
            scheduling_strategy: self.scheduling_strategy,
            total_memory_limit: self.total_memory_limit,
            total_cpu_limit: self.total_cpu_limit,
            container_definitions: self.container_definitions,
            operating_system: self.operating_system,
            tags: self.tags,
        })
    }
}
