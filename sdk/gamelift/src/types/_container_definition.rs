// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p><b>This data type is used with the Amazon GameLift containers feature, which is currently in public preview.</b></p>
/// <p>Describes a container in a container fleet, the resources available to the container, and the commands that are run when the container starts. Container properties can't be updated. To change a property, create a new container group definition. See also <code>ContainerDefinitionInput</code>.</p>
/// <p><b>Part of:</b> <code>ContainerGroupDefinition</code></p>
/// <p><b>Returned by:</b> <code>DescribeContainerGroupDefinition</code>, <code>ListContainerGroupDefinitions</code></p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ContainerDefinition {
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub container_name: ::std::option::Option<::std::string::String>,
    /// <p>The URI to the image that $short; copied and deployed to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub image_uri: ::std::option::Option<::std::string::String>,
    /// <p>A unique and immutable identifier for the container image that is deployed to a container fleet. The digest is a SHA 256 hash of the container image manifest.</p>
    pub resolved_image_digest: ::std::option::Option<::std::string::String>,
    /// <p>The amount of memory that Amazon GameLift makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub memory_limits: ::std::option::Option<crate::types::ContainerMemoryLimits>,
    /// <p>Defines the ports that are available to assign to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    /// <p>The number of CPU units that are reserved for the container. Note: 1 vCPU unit equals 1024 CPU units. If no resources are reserved, the container shares the total CPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub cpu: ::std::option::Option<i32>,
    /// <p>A configuration for a non-terminal health check. A container, which automatically restarts if it stops functioning, also restarts if it fails this health check. If an essential container in the daemon group fails a health check, the entire container group is restarted. The essential container in the replica group doesn't use this health check mechanism, because the Amazon GameLift Agent automatically handles the task.</p>
    pub health_check: ::std::option::Option<crate::types::ContainerHealthCheck>,
    /// <p>A command that's passed to the container on startup. Each argument for the command is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition::command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    pub command: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group is restarted.</p>
    pub essential: ::std::option::Option<bool>,
    /// <p>The entry point that's passed to the container on startup. If there are multiple arguments, each argument is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub entry_point: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub working_directory: ::std::option::Option<::std::string::String>,
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub environment: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
}
impl ContainerDefinition {
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn container_name(&self) -> ::std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>The URI to the image that $short; copied and deployed to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn image_uri(&self) -> ::std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>A unique and immutable identifier for the container image that is deployed to a container fleet. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn resolved_image_digest(&self) -> ::std::option::Option<&str> {
        self.resolved_image_digest.as_deref()
    }
    /// <p>The amount of memory that Amazon GameLift makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub fn memory_limits(&self) -> ::std::option::Option<&crate::types::ContainerMemoryLimits> {
        self.memory_limits.as_ref()
    }
    /// <p>Defines the ports that are available to assign to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(&self) -> ::std::option::Option<&crate::types::ContainerPortConfiguration> {
        self.port_configuration.as_ref()
    }
    /// <p>The number of CPU units that are reserved for the container. Note: 1 vCPU unit equals 1024 CPU units. If no resources are reserved, the container shares the total CPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub fn cpu(&self) -> ::std::option::Option<i32> {
        self.cpu
    }
    /// <p>A configuration for a non-terminal health check. A container, which automatically restarts if it stops functioning, also restarts if it fails this health check. If an essential container in the daemon group fails a health check, the entire container group is restarted. The essential container in the replica group doesn't use this health check mechanism, because the Amazon GameLift Agent automatically handles the task.</p>
    pub fn health_check(&self) -> ::std::option::Option<&crate::types::ContainerHealthCheck> {
        self.health_check.as_ref()
    }
    /// <p>A command that's passed to the container on startup. Each argument for the command is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition::command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.command.is_none()`.
    pub fn command(&self) -> &[::std::string::String] {
        self.command.as_deref().unwrap_or_default()
    }
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group is restarted.</p>
    pub fn essential(&self) -> ::std::option::Option<bool> {
        self.essential
    }
    /// <p>The entry point that's passed to the container on startup. If there are multiple arguments, each argument is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.entry_point.is_none()`.
    pub fn entry_point(&self) -> &[::std::string::String] {
        self.entry_point.as_deref().unwrap_or_default()
    }
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn working_directory(&self) -> ::std::option::Option<&str> {
        self.working_directory.as_deref()
    }
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.environment.is_none()`.
    pub fn environment(&self) -> &[crate::types::ContainerEnvironment] {
        self.environment.as_deref().unwrap_or_default()
    }
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.depends_on.is_none()`.
    pub fn depends_on(&self) -> &[crate::types::ContainerDependency] {
        self.depends_on.as_deref().unwrap_or_default()
    }
}
impl ContainerDefinition {
    /// Creates a new builder-style object to manufacture [`ContainerDefinition`](crate::types::ContainerDefinition).
    pub fn builder() -> crate::types::builders::ContainerDefinitionBuilder {
        crate::types::builders::ContainerDefinitionBuilder::default()
    }
}

/// A builder for [`ContainerDefinition`](crate::types::ContainerDefinition).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ContainerDefinitionBuilder {
    pub(crate) container_name: ::std::option::Option<::std::string::String>,
    pub(crate) image_uri: ::std::option::Option<::std::string::String>,
    pub(crate) resolved_image_digest: ::std::option::Option<::std::string::String>,
    pub(crate) memory_limits: ::std::option::Option<crate::types::ContainerMemoryLimits>,
    pub(crate) port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    pub(crate) cpu: ::std::option::Option<i32>,
    pub(crate) health_check: ::std::option::Option<crate::types::ContainerHealthCheck>,
    pub(crate) command: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) essential: ::std::option::Option<bool>,
    pub(crate) entry_point: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) working_directory: ::std::option::Option<::std::string::String>,
    pub(crate) environment: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    pub(crate) depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
}
impl ContainerDefinitionBuilder {
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    /// This field is required.
    pub fn container_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.container_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn set_container_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.container_name = input;
        self
    }
    /// <p>The container definition identifier. Container names are unique within a container group definition.</p>
    pub fn get_container_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.container_name
    }
    /// <p>The URI to the image that $short; copied and deployed to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    /// This field is required.
    pub fn image_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.image_uri = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The URI to the image that $short; copied and deployed to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn set_image_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.image_uri = input;
        self
    }
    /// <p>The URI to the image that $short; copied and deployed to a container fleet. For a more specific identifier, see <code>ResolvedImageDigest</code>.</p>
    pub fn get_image_uri(&self) -> &::std::option::Option<::std::string::String> {
        &self.image_uri
    }
    /// <p>A unique and immutable identifier for the container image that is deployed to a container fleet. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn resolved_image_digest(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.resolved_image_digest = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique and immutable identifier for the container image that is deployed to a container fleet. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn set_resolved_image_digest(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.resolved_image_digest = input;
        self
    }
    /// <p>A unique and immutable identifier for the container image that is deployed to a container fleet. The digest is a SHA 256 hash of the container image manifest.</p>
    pub fn get_resolved_image_digest(&self) -> &::std::option::Option<::std::string::String> {
        &self.resolved_image_digest
    }
    /// <p>The amount of memory that Amazon GameLift makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub fn memory_limits(mut self, input: crate::types::ContainerMemoryLimits) -> Self {
        self.memory_limits = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of memory that Amazon GameLift makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub fn set_memory_limits(mut self, input: ::std::option::Option<crate::types::ContainerMemoryLimits>) -> Self {
        self.memory_limits = input;
        self
    }
    /// <p>The amount of memory that Amazon GameLift makes available to the container. If memory limits aren't set for an individual container, the container shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub fn get_memory_limits(&self) -> &::std::option::Option<crate::types::ContainerMemoryLimits> {
        &self.memory_limits
    }
    /// <p>Defines the ports that are available to assign to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(mut self, input: crate::types::ContainerPortConfiguration) -> Self {
        self.port_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the ports that are available to assign to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn set_port_configuration(mut self, input: ::std::option::Option<crate::types::ContainerPortConfiguration>) -> Self {
        self.port_configuration = input;
        self
    }
    /// <p>Defines the ports that are available to assign to processes in the container. For example, a game server process requires a container port to allow game clients to connect to it. Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn get_port_configuration(&self) -> &::std::option::Option<crate::types::ContainerPortConfiguration> {
        &self.port_configuration
    }
    /// <p>The number of CPU units that are reserved for the container. Note: 1 vCPU unit equals 1024 CPU units. If no resources are reserved, the container shares the total CPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub fn cpu(mut self, input: i32) -> Self {
        self.cpu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of CPU units that are reserved for the container. Note: 1 vCPU unit equals 1024 CPU units. If no resources are reserved, the container shares the total CPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub fn set_cpu(mut self, input: ::std::option::Option<i32>) -> Self {
        self.cpu = input;
        self
    }
    /// <p>The number of CPU units that are reserved for the container. Note: 1 vCPU unit equals 1024 CPU units. If no resources are reserved, the container shares the total CPU limit for the container group.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub fn get_cpu(&self) -> &::std::option::Option<i32> {
        &self.cpu
    }
    /// <p>A configuration for a non-terminal health check. A container, which automatically restarts if it stops functioning, also restarts if it fails this health check. If an essential container in the daemon group fails a health check, the entire container group is restarted. The essential container in the replica group doesn't use this health check mechanism, because the Amazon GameLift Agent automatically handles the task.</p>
    pub fn health_check(mut self, input: crate::types::ContainerHealthCheck) -> Self {
        self.health_check = ::std::option::Option::Some(input);
        self
    }
    /// <p>A configuration for a non-terminal health check. A container, which automatically restarts if it stops functioning, also restarts if it fails this health check. If an essential container in the daemon group fails a health check, the entire container group is restarted. The essential container in the replica group doesn't use this health check mechanism, because the Amazon GameLift Agent automatically handles the task.</p>
    pub fn set_health_check(mut self, input: ::std::option::Option<crate::types::ContainerHealthCheck>) -> Self {
        self.health_check = input;
        self
    }
    /// <p>A configuration for a non-terminal health check. A container, which automatically restarts if it stops functioning, also restarts if it fails this health check. If an essential container in the daemon group fails a health check, the entire container group is restarted. The essential container in the replica group doesn't use this health check mechanism, because the Amazon GameLift Agent automatically handles the task.</p>
    pub fn get_health_check(&self) -> &::std::option::Option<crate::types::ContainerHealthCheck> {
        &self.health_check
    }
    /// Appends an item to `command`.
    ///
    /// To override the contents of this collection use [`set_command`](Self::set_command).
    ///
    /// <p>A command that's passed to the container on startup. Each argument for the command is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition::command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    pub fn command(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.command.unwrap_or_default();
        v.push(input.into());
        self.command = ::std::option::Option::Some(v);
        self
    }
    /// <p>A command that's passed to the container on startup. Each argument for the command is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition::command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    pub fn set_command(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.command = input;
        self
    }
    /// <p>A command that's passed to the container on startup. Each argument for the command is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition::command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    pub fn get_command(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.command
    }
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group is restarted.</p>
    pub fn essential(mut self, input: bool) -> Self {
        self.essential = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group is restarted.</p>
    pub fn set_essential(mut self, input: ::std::option::Option<bool>) -> Self {
        self.essential = input;
        self
    }
    /// <p>Indicates whether the container is vital to the container group. If an essential container fails, the entire container group is restarted.</p>
    pub fn get_essential(&self) -> &::std::option::Option<bool> {
        &self.essential
    }
    /// Appends an item to `entry_point`.
    ///
    /// To override the contents of this collection use [`set_entry_point`](Self::set_entry_point).
    ///
    /// <p>The entry point that's passed to the container on startup. If there are multiple arguments, each argument is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn entry_point(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.entry_point.unwrap_or_default();
        v.push(input.into());
        self.entry_point = ::std::option::Option::Some(v);
        self
    }
    /// <p>The entry point that's passed to the container on startup. If there are multiple arguments, each argument is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_entry_point(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.entry_point = input;
        self
    }
    /// <p>The entry point that's passed to the container on startup. If there are multiple arguments, each argument is an additional string in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_entry_point(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.entry_point
    }
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn working_directory(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.working_directory = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_working_directory(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.working_directory = input;
        self
    }
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_working_directory(&self) -> &::std::option::Option<::std::string::String> {
        &self.working_directory
    }
    /// Appends an item to `environment`.
    ///
    /// To override the contents of this collection use [`set_environment`](Self::set_environment).
    ///
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn environment(mut self, input: crate::types::ContainerEnvironment) -> Self {
        let mut v = self.environment.unwrap_or_default();
        v.push(input);
        self.environment = ::std::option::Option::Some(v);
        self
    }
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_environment(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>) -> Self {
        self.environment = input;
        self
    }
    /// <p>A set of environment variables that's passed to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_environment(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>> {
        &self.environment
    }
    /// Appends an item to `depends_on`.
    ///
    /// To override the contents of this collection use [`set_depends_on`](Self::set_depends_on).
    ///
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub fn depends_on(mut self, input: crate::types::ContainerDependency) -> Self {
        let mut v = self.depends_on.unwrap_or_default();
        v.push(input);
        self.depends_on = ::std::option::Option::Some(v);
        self
    }
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub fn set_depends_on(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>) -> Self {
        self.depends_on = input;
        self
    }
    /// <p>Indicates that the container relies on the status of other containers in the same container group during its startup and shutdown sequences. A container might have dependencies on multiple containers.</p>
    pub fn get_depends_on(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>> {
        &self.depends_on
    }
    /// Consumes the builder and constructs a [`ContainerDefinition`](crate::types::ContainerDefinition).
    pub fn build(self) -> crate::types::ContainerDefinition {
        crate::types::ContainerDefinition {
            container_name: self.container_name,
            image_uri: self.image_uri,
            resolved_image_digest: self.resolved_image_digest,
            memory_limits: self.memory_limits,
            port_configuration: self.port_configuration,
            cpu: self.cpu,
            health_check: self.health_check,
            command: self.command,
            essential: self.essential,
            entry_point: self.entry_point,
            working_directory: self.working_directory,
            environment: self.environment,
            depends_on: self.depends_on,
        }
    }
}
