// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p><b>This data type is used with the Amazon GameLift containers feature, which is currently in public preview.</b></p>
/// <p>Describes a container's configuration, resources, and start instructions. Use this data type to create a container group definition. For the properties of a container that's been deployed to a fleet, see <code>ContainerDefinition</code>. You can't change these properties after you've created the container group definition. If you need a container group with different properties, then you must create a new one.</p>
/// <p><b>Used with: </b> <code>CreateContainerGroupDefinition</code></p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ContainerDefinitionInput {
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub container_name: ::std::option::Option<::std::string::String>,
    /// <p>The location of a container image that $short; will copy and deploy to a container fleet. Images in Amazon Elastic Container Registry private repositories are supported. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]@[digest]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]:[tag]</code></p></li>
    /// </ul>
    pub image_uri: ::std::option::Option<::std::string::String>,
    /// <p>The amount of memory to make available to the container. If you don't specify memory limits for this container, then it shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub memory_limits: ::std::option::Option<crate::types::ContainerMemoryLimits>,
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. All processes that accept inbound traffic connections, including game server processes, must be assigned a port from this set. The set of ports must be large enough to assign one to each process in the container that needs one. If the container includes your game server, include enough ports to assign one port to each concurrent server process (as defined in a container fleet's <code>RuntimeConfiguration</code>). For more details, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-network">Networking for container fleets</a>.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    /// <p>The number of CPU units to reserve for this container. The container can use more resources when needed, if available. Note: 1 vCPU unit equals 1024 CPU units. If you don't reserve CPU units for this container, then it shares the total CPU limit for the container group. This property is similar to the Amazon ECS container definition parameter <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definition_environment">environment</a> (<i>Amazon Elastic Container Service Developer Guide).</i></p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub cpu: ::std::option::Option<i32>,
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. This parameter lets you define additional reasons to consider a container unhealthy and restart it. You can set a health check for any container except for the essential container in the replica container group. If an essential container in the daemon group fails a health check, the entire container group is restarted.</p>
    pub health_check: ::std::option::Option<crate::types::ContainerHealthCheck>,
    /// <p>A command to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    pub command: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>Specifies whether the container is vital for the container group to function properly. If an essential container fails, it causes the entire container group to restart. Each container group must have an essential container.</p>
    /// <p><b>Replica container groups</b> - A replica group must have exactly one essential container. Use the following to configure an essential replica container:</p>
    /// <ul>
    /// <li>
    /// <p>Choose a container is running your game server and the Amazon GameLift Agent.</p></li>
    /// <li>
    /// <p>Include a port configuration. This container runs your game server processes, and each process requires a container port to allow access to game clients.</p></li>
    /// <li>
    /// <p>Don't configure a health check. The Agent handles this task for the essential replica container.</p></li>
    /// </ul>
    /// <p><b>Daemon container groups</b> - A daemon group must have at least one essential container.</p>
    /// <p></p>
    pub essential: ::std::option::Option<bool>,
    /// <p>An entry point to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub entry_point: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory parameter</a> in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub working_directory: ::std::option::Option<::std::string::String>,
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub environment: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    /// <p>Sets up dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. A container startup dependency is reversed on shutdown.</p>
    /// <p>For example, you might specify that SideCarContainerB has a <code>START</code> dependency on SideCarContainerA. This dependency means that SideCarContainerB can't start until after SideCarContainerA has started. This dependency is reversed on shutdown, which means that SideCarContainerB must shut down before SideCarContainerA can shut down.</p>
    pub depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
}
impl ContainerDefinitionInput {
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub fn container_name(&self) -> ::std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>The location of a container image that $short; will copy and deploy to a container fleet. Images in Amazon Elastic Container Registry private repositories are supported. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]@[digest]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]:[tag]</code></p></li>
    /// </ul>
    pub fn image_uri(&self) -> ::std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>The amount of memory to make available to the container. If you don't specify memory limits for this container, then it shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub fn memory_limits(&self) -> ::std::option::Option<&crate::types::ContainerMemoryLimits> {
        self.memory_limits.as_ref()
    }
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. All processes that accept inbound traffic connections, including game server processes, must be assigned a port from this set. The set of ports must be large enough to assign one to each process in the container that needs one. If the container includes your game server, include enough ports to assign one port to each concurrent server process (as defined in a container fleet's <code>RuntimeConfiguration</code>). For more details, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-network">Networking for container fleets</a>.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(&self) -> ::std::option::Option<&crate::types::ContainerPortConfiguration> {
        self.port_configuration.as_ref()
    }
    /// <p>The number of CPU units to reserve for this container. The container can use more resources when needed, if available. Note: 1 vCPU unit equals 1024 CPU units. If you don't reserve CPU units for this container, then it shares the total CPU limit for the container group. This property is similar to the Amazon ECS container definition parameter <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definition_environment">environment</a> (<i>Amazon Elastic Container Service Developer Guide).</i></p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub fn cpu(&self) -> ::std::option::Option<i32> {
        self.cpu
    }
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. This parameter lets you define additional reasons to consider a container unhealthy and restart it. You can set a health check for any container except for the essential container in the replica container group. If an essential container in the daemon group fails a health check, the entire container group is restarted.</p>
    pub fn health_check(&self) -> ::std::option::Option<&crate::types::ContainerHealthCheck> {
        self.health_check.as_ref()
    }
    /// <p>A command to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.command.is_none()`.
    pub fn command(&self) -> &[::std::string::String] {
        self.command.as_deref().unwrap_or_default()
    }
    /// <p>Specifies whether the container is vital for the container group to function properly. If an essential container fails, it causes the entire container group to restart. Each container group must have an essential container.</p>
    /// <p><b>Replica container groups</b> - A replica group must have exactly one essential container. Use the following to configure an essential replica container:</p>
    /// <ul>
    /// <li>
    /// <p>Choose a container is running your game server and the Amazon GameLift Agent.</p></li>
    /// <li>
    /// <p>Include a port configuration. This container runs your game server processes, and each process requires a container port to allow access to game clients.</p></li>
    /// <li>
    /// <p>Don't configure a health check. The Agent handles this task for the essential replica container.</p></li>
    /// </ul>
    /// <p><b>Daemon container groups</b> - A daemon group must have at least one essential container.</p>
    /// <p></p>
    pub fn essential(&self) -> ::std::option::Option<bool> {
        self.essential
    }
    /// <p>An entry point to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.entry_point.is_none()`.
    pub fn entry_point(&self) -> &[::std::string::String] {
        self.entry_point.as_deref().unwrap_or_default()
    }
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory parameter</a> in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn working_directory(&self) -> ::std::option::Option<&str> {
        self.working_directory.as_deref()
    }
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.environment.is_none()`.
    pub fn environment(&self) -> &[crate::types::ContainerEnvironment] {
        self.environment.as_deref().unwrap_or_default()
    }
    /// <p>Sets up dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. A container startup dependency is reversed on shutdown.</p>
    /// <p>For example, you might specify that SideCarContainerB has a <code>START</code> dependency on SideCarContainerA. This dependency means that SideCarContainerB can't start until after SideCarContainerA has started. This dependency is reversed on shutdown, which means that SideCarContainerB must shut down before SideCarContainerA can shut down.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.depends_on.is_none()`.
    pub fn depends_on(&self) -> &[crate::types::ContainerDependency] {
        self.depends_on.as_deref().unwrap_or_default()
    }
}
impl ContainerDefinitionInput {
    /// Creates a new builder-style object to manufacture [`ContainerDefinitionInput`](crate::types::ContainerDefinitionInput).
    pub fn builder() -> crate::types::builders::ContainerDefinitionInputBuilder {
        crate::types::builders::ContainerDefinitionInputBuilder::default()
    }
}

/// A builder for [`ContainerDefinitionInput`](crate::types::ContainerDefinitionInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ContainerDefinitionInputBuilder {
    pub(crate) container_name: ::std::option::Option<::std::string::String>,
    pub(crate) image_uri: ::std::option::Option<::std::string::String>,
    pub(crate) memory_limits: ::std::option::Option<crate::types::ContainerMemoryLimits>,
    pub(crate) port_configuration: ::std::option::Option<crate::types::ContainerPortConfiguration>,
    pub(crate) cpu: ::std::option::Option<i32>,
    pub(crate) health_check: ::std::option::Option<crate::types::ContainerHealthCheck>,
    pub(crate) command: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) essential: ::std::option::Option<bool>,
    pub(crate) entry_point: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) working_directory: ::std::option::Option<::std::string::String>,
    pub(crate) environment: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>,
    pub(crate) depends_on: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>,
}
impl ContainerDefinitionInputBuilder {
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    /// This field is required.
    pub fn container_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.container_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub fn set_container_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.container_name = input;
        self
    }
    /// <p>A string that uniquely identifies the container definition within a container group.</p>
    pub fn get_container_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.container_name
    }
    /// <p>The location of a container image that $short; will copy and deploy to a container fleet. Images in Amazon Elastic Container Registry private repositories are supported. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]@[digest]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]:[tag]</code></p></li>
    /// </ul>
    /// This field is required.
    pub fn image_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.image_uri = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The location of a container image that $short; will copy and deploy to a container fleet. Images in Amazon Elastic Container Registry private repositories are supported. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]@[digest]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]:[tag]</code></p></li>
    /// </ul>
    pub fn set_image_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.image_uri = input;
        self
    }
    /// <p>The location of a container image that $short; will copy and deploy to a container fleet. Images in Amazon Elastic Container Registry private repositories are supported. The repository must be in the same Amazon Web Services account and Amazon Web Services Region where you're creating the container group definition. For limits on image size, see <a href="https://docs.aws.amazon.com/general/latest/gr/gamelift.html">Amazon GameLift endpoints and quotas</a>. You can use any of the following image URI formats:</p>
    /// <ul>
    /// <li>
    /// <p>Image ID only: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]</code></p></li>
    /// <li>
    /// <p>Image ID and digest: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]@[digest]</code></p></li>
    /// <li>
    /// <p>Image ID and tag: <code>[AWS account].dkr.ecr.[AWS region].amazonaws.com/[repository ID]:[tag]</code></p></li>
    /// </ul>
    pub fn get_image_uri(&self) -> &::std::option::Option<::std::string::String> {
        &self.image_uri
    }
    /// <p>The amount of memory to make available to the container. If you don't specify memory limits for this container, then it shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub fn memory_limits(mut self, input: crate::types::ContainerMemoryLimits) -> Self {
        self.memory_limits = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of memory to make available to the container. If you don't specify memory limits for this container, then it shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub fn set_memory_limits(mut self, input: ::std::option::Option<crate::types::ContainerMemoryLimits>) -> Self {
        self.memory_limits = input;
        self
    }
    /// <p>The amount of memory to make available to the container. If you don't specify memory limits for this container, then it shares the container group's total memory allocation.</p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalMemoryLimit</code></p>
    pub fn get_memory_limits(&self) -> &::std::option::Option<crate::types::ContainerMemoryLimits> {
        &self.memory_limits
    }
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. All processes that accept inbound traffic connections, including game server processes, must be assigned a port from this set. The set of ports must be large enough to assign one to each process in the container that needs one. If the container includes your game server, include enough ports to assign one port to each concurrent server process (as defined in a container fleet's <code>RuntimeConfiguration</code>). For more details, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-network">Networking for container fleets</a>.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn port_configuration(mut self, input: crate::types::ContainerPortConfiguration) -> Self {
        self.port_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. All processes that accept inbound traffic connections, including game server processes, must be assigned a port from this set. The set of ports must be large enough to assign one to each process in the container that needs one. If the container includes your game server, include enough ports to assign one port to each concurrent server process (as defined in a container fleet's <code>RuntimeConfiguration</code>). For more details, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-network">Networking for container fleets</a>.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn set_port_configuration(mut self, input: ::std::option::Option<crate::types::ContainerPortConfiguration>) -> Self {
        self.port_configuration = input;
        self
    }
    /// <p>A set of ports that Amazon GameLift can assign to processes in the container. All processes that accept inbound traffic connections, including game server processes, must be assigned a port from this set. The set of ports must be large enough to assign one to each process in the container that needs one. If the container includes your game server, include enough ports to assign one port to each concurrent server process (as defined in a container fleet's <code>RuntimeConfiguration</code>). For more details, see <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/containers-network">Networking for container fleets</a>.</p>
    /// <p>Container ports aren't directly accessed by inbound traffic. Amazon GameLift maps these container ports to externally accessible connection ports, which are assigned as needed from the container fleet's <code>ConnectionPortRange</code>.</p>
    pub fn get_port_configuration(&self) -> &::std::option::Option<crate::types::ContainerPortConfiguration> {
        &self.port_configuration
    }
    /// <p>The number of CPU units to reserve for this container. The container can use more resources when needed, if available. Note: 1 vCPU unit equals 1024 CPU units. If you don't reserve CPU units for this container, then it shares the total CPU limit for the container group. This property is similar to the Amazon ECS container definition parameter <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definition_environment">environment</a> (<i>Amazon Elastic Container Service Developer Guide).</i></p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub fn cpu(mut self, input: i32) -> Self {
        self.cpu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of CPU units to reserve for this container. The container can use more resources when needed, if available. Note: 1 vCPU unit equals 1024 CPU units. If you don't reserve CPU units for this container, then it shares the total CPU limit for the container group. This property is similar to the Amazon ECS container definition parameter <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definition_environment">environment</a> (<i>Amazon Elastic Container Service Developer Guide).</i></p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub fn set_cpu(mut self, input: ::std::option::Option<i32>) -> Self {
        self.cpu = input;
        self
    }
    /// <p>The number of CPU units to reserve for this container. The container can use more resources when needed, if available. Note: 1 vCPU unit equals 1024 CPU units. If you don't reserve CPU units for this container, then it shares the total CPU limit for the container group. This property is similar to the Amazon ECS container definition parameter <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definition_environment">environment</a> (<i>Amazon Elastic Container Service Developer Guide).</i></p>
    /// <p><b>Related data type: </b> <code>ContainerGroupDefinition$TotalCpuLimit</code></p>
    pub fn get_cpu(&self) -> &::std::option::Option<i32> {
        &self.cpu
    }
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. This parameter lets you define additional reasons to consider a container unhealthy and restart it. You can set a health check for any container except for the essential container in the replica container group. If an essential container in the daemon group fails a health check, the entire container group is restarted.</p>
    pub fn health_check(mut self, input: crate::types::ContainerHealthCheck) -> Self {
        self.health_check = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. This parameter lets you define additional reasons to consider a container unhealthy and restart it. You can set a health check for any container except for the essential container in the replica container group. If an essential container in the daemon group fails a health check, the entire container group is restarted.</p>
    pub fn set_health_check(mut self, input: ::std::option::Option<crate::types::ContainerHealthCheck>) -> Self {
        self.health_check = input;
        self
    }
    /// <p>Configuration for a non-terminal health check. A container automatically restarts if it stops functioning. This parameter lets you define additional reasons to consider a container unhealthy and restart it. You can set a health check for any container except for the essential container in the replica container group. If an essential container in the daemon group fails a health check, the entire container group is restarted.</p>
    pub fn get_health_check(&self) -> &::std::option::Option<crate::types::ContainerHealthCheck> {
        &self.health_check
    }
    /// Appends an item to `command`.
    ///
    /// To override the contents of this collection use [`set_command`](Self::set_command).
    ///
    /// <p>A command to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    pub fn command(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.command.unwrap_or_default();
        v.push(input.into());
        self.command = ::std::option::Option::Some(v);
        self
    }
    /// <p>A command to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    pub fn set_command(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.command = input;
        self
    }
    /// <p>A command to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-command">ContainerDefinition command</a> parameter in the <i>Amazon Elastic Container Service API reference.</i></p>
    pub fn get_command(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.command
    }
    /// <p>Specifies whether the container is vital for the container group to function properly. If an essential container fails, it causes the entire container group to restart. Each container group must have an essential container.</p>
    /// <p><b>Replica container groups</b> - A replica group must have exactly one essential container. Use the following to configure an essential replica container:</p>
    /// <ul>
    /// <li>
    /// <p>Choose a container is running your game server and the Amazon GameLift Agent.</p></li>
    /// <li>
    /// <p>Include a port configuration. This container runs your game server processes, and each process requires a container port to allow access to game clients.</p></li>
    /// <li>
    /// <p>Don't configure a health check. The Agent handles this task for the essential replica container.</p></li>
    /// </ul>
    /// <p><b>Daemon container groups</b> - A daemon group must have at least one essential container.</p>
    /// <p></p>
    pub fn essential(mut self, input: bool) -> Self {
        self.essential = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether the container is vital for the container group to function properly. If an essential container fails, it causes the entire container group to restart. Each container group must have an essential container.</p>
    /// <p><b>Replica container groups</b> - A replica group must have exactly one essential container. Use the following to configure an essential replica container:</p>
    /// <ul>
    /// <li>
    /// <p>Choose a container is running your game server and the Amazon GameLift Agent.</p></li>
    /// <li>
    /// <p>Include a port configuration. This container runs your game server processes, and each process requires a container port to allow access to game clients.</p></li>
    /// <li>
    /// <p>Don't configure a health check. The Agent handles this task for the essential replica container.</p></li>
    /// </ul>
    /// <p><b>Daemon container groups</b> - A daemon group must have at least one essential container.</p>
    /// <p></p>
    pub fn set_essential(mut self, input: ::std::option::Option<bool>) -> Self {
        self.essential = input;
        self
    }
    /// <p>Specifies whether the container is vital for the container group to function properly. If an essential container fails, it causes the entire container group to restart. Each container group must have an essential container.</p>
    /// <p><b>Replica container groups</b> - A replica group must have exactly one essential container. Use the following to configure an essential replica container:</p>
    /// <ul>
    /// <li>
    /// <p>Choose a container is running your game server and the Amazon GameLift Agent.</p></li>
    /// <li>
    /// <p>Include a port configuration. This container runs your game server processes, and each process requires a container port to allow access to game clients.</p></li>
    /// <li>
    /// <p>Don't configure a health check. The Agent handles this task for the essential replica container.</p></li>
    /// </ul>
    /// <p><b>Daemon container groups</b> - A daemon group must have at least one essential container.</p>
    /// <p></p>
    pub fn get_essential(&self) -> &::std::option::Option<bool> {
        &self.essential
    }
    /// Appends an item to `entry_point`.
    ///
    /// To override the contents of this collection use [`set_entry_point`](Self::set_entry_point).
    ///
    /// <p>An entry point to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn entry_point(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.entry_point.unwrap_or_default();
        v.push(input.into());
        self.entry_point = ::std::option::Option::Some(v);
        self
    }
    /// <p>An entry point to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_entry_point(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.entry_point = input;
        self
    }
    /// <p>An entry point to pass to the container on startup. Add multiple arguments as additional strings in the array. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-entryPoint">ContainerDefinition::entryPoint</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_entry_point(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.entry_point
    }
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory parameter</a> in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn working_directory(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.working_directory = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory parameter</a> in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_working_directory(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.working_directory = input;
        self
    }
    /// <p>The directory in the container where commands are run. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-workingDirectory">ContainerDefinition::workingDirectory parameter</a> in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_working_directory(&self) -> &::std::option::Option<::std::string::String> {
        &self.working_directory
    }
    /// Appends an item to `environment`.
    ///
    /// To override the contents of this collection use [`set_environment`](Self::set_environment).
    ///
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn environment(mut self, input: crate::types::ContainerEnvironment) -> Self {
        let mut v = self.environment.unwrap_or_default();
        v.push(input);
        self.environment = ::std::option::Option::Some(v);
        self
    }
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn set_environment(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>>) -> Self {
        self.environment = input;
        self
    }
    /// <p>A set of environment variables to pass to the container on startup. See the <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html#ECS-Type-ContainerDefinition-environment">ContainerDefinition::environment</a> parameter in the <i>Amazon Elastic Container Service API Reference</i>.</p>
    pub fn get_environment(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerEnvironment>> {
        &self.environment
    }
    /// Appends an item to `depends_on`.
    ///
    /// To override the contents of this collection use [`set_depends_on`](Self::set_depends_on).
    ///
    /// <p>Sets up dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. A container startup dependency is reversed on shutdown.</p>
    /// <p>For example, you might specify that SideCarContainerB has a <code>START</code> dependency on SideCarContainerA. This dependency means that SideCarContainerB can't start until after SideCarContainerA has started. This dependency is reversed on shutdown, which means that SideCarContainerB must shut down before SideCarContainerA can shut down.</p>
    pub fn depends_on(mut self, input: crate::types::ContainerDependency) -> Self {
        let mut v = self.depends_on.unwrap_or_default();
        v.push(input);
        self.depends_on = ::std::option::Option::Some(v);
        self
    }
    /// <p>Sets up dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. A container startup dependency is reversed on shutdown.</p>
    /// <p>For example, you might specify that SideCarContainerB has a <code>START</code> dependency on SideCarContainerA. This dependency means that SideCarContainerB can't start until after SideCarContainerA has started. This dependency is reversed on shutdown, which means that SideCarContainerB must shut down before SideCarContainerA can shut down.</p>
    pub fn set_depends_on(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>>) -> Self {
        self.depends_on = input;
        self
    }
    /// <p>Sets up dependencies between this container and the status of other containers in the same container group. A container can have dependencies on multiple different containers.</p>
    /// <p>You can use dependencies to establish a startup/shutdown sequence across the container group. A container startup dependency is reversed on shutdown.</p>
    /// <p>For example, you might specify that SideCarContainerB has a <code>START</code> dependency on SideCarContainerA. This dependency means that SideCarContainerB can't start until after SideCarContainerA has started. This dependency is reversed on shutdown, which means that SideCarContainerB must shut down before SideCarContainerA can shut down.</p>
    pub fn get_depends_on(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContainerDependency>> {
        &self.depends_on
    }
    /// Consumes the builder and constructs a [`ContainerDefinitionInput`](crate::types::ContainerDefinitionInput).
    pub fn build(self) -> crate::types::ContainerDefinitionInput {
        crate::types::ContainerDefinitionInput {
            container_name: self.container_name,
            image_uri: self.image_uri,
            memory_limits: self.memory_limits,
            port_configuration: self.port_configuration,
            cpu: self.cpu,
            health_check: self.health_check,
            command: self.command,
            essential: self.essential,
            entry_point: self.entry_point,
            working_directory: self.working_directory,
            environment: self.environment,
            depends_on: self.depends_on,
        }
    }
}
